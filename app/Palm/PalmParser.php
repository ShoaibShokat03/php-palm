<?php

namespace Frontend\Palm;

/**
 * Parser for .palm.php files
 * Builds an AST from tokens generated by PalmLexer
 */
class PalmParser
{
    protected array $tokens;
    protected int $position = 0;
    protected array $ast = [];

    public function __construct(array $tokens)
    {
        $this->tokens = $tokens;
    }

    public function parse(): array
    {
        $this->position = 0;
        $this->ast = [
            'type' => 'Document',
            'children' => [],
        ];

        while (!$this->isEOF()) {
            $node = $this->parseNode();
            if ($node !== null) {
                $this->ast['children'][] = $node;
            }
        }

        return $this->ast;
    }

    protected function parseNode(): ?array
    {
        $token = $this->current();

        // Text node
        if ($token['type'] === 'TEXT') {
            $this->advance();
            return [
                'type' => 'Text',
                'value' => $token['value'],
                'line' => $token['line'],
                'column' => $token['column'],
            ];
        }

        // PHP code
        if ($token['type'] === 'PHP_OPEN' || $token['type'] === 'PHP_ECHO' || $token['type'] === 'PHP_CODE') {
            return $this->parsePhp();
        }

        // HTML tag
        if ($token['type'] === 'TAG_OPEN') {
            return $this->parseElement();
        }

        // Expression { }
        if ($token['type'] === 'LBRACE') {
            return $this->parseExpression();
        }

        $this->advance();
        return null;
    }

    protected function parsePhp(): array
    {
        $token = $this->current();
        $isEcho = $token['type'] === 'PHP_ECHO';
        
        $this->advance(); // Skip PHP_ECHO or PHP_OPEN
        
        // Read PHP code token if it exists
        $code = '';
        $codeToken = $this->current();
        if ($codeToken['type'] === 'PHP_CODE') {
            $code = $codeToken['value'];
            $this->advance(); // Skip PHP_CODE
        }
        
        // Skip PHP_CLOSE if it exists
        $closeToken = $this->current();
        if ($closeToken['type'] === 'PHP_CLOSE') {
            $this->advance(); // Skip PHP_CLOSE
        }

        return [
            'type' => 'Php',
            'code' => $code,
            'isEcho' => $isEcho,
            'line' => $token['line'],
            'column' => $token['column'],
        ];
    }

    protected function parseElement(): array
    {
        $openToken = $this->current();
        $this->advance(); // Skip TAG_OPEN

        $nameToken = $this->current();
        $tagName = $nameToken['value'];
        $this->advance(); // Skip TAG_NAME

        // Parse attributes
        $attributes = [];
        while ($this->current()['type'] === 'ATTR_NAME') {
            $attr = $this->parseAttribute();
            if ($attr !== null) {
                $attributes[$attr['name']] = $attr['value'];
            }
        }

        // Check if self-closing
        $isSelfClosing = false;
        if ($this->current()['type'] === 'TAG_SELF_CLOSE') {
            $isSelfClosing = true;
            $this->advance(); // Skip TAG_SELF_CLOSE
        } elseif ($this->current()['type'] === 'TAG_CLOSE') {
            $this->advance(); // Skip TAG_CLOSE
        }

        $element = [
            'type' => 'Element',
            'tag' => $tagName,
            'attributes' => $attributes,
            'children' => [],
            'isSelfClosing' => $isSelfClosing,
            'line' => $openToken['line'],
            'column' => $openToken['column'],
        ];

        // Parse children if not self-closing
        if (!$isSelfClosing) {
            // Parse content until closing tag
            while (!$this->isEOF()) {
                // Check for closing tag
                if ($this->current()['type'] === 'TAG_CLOSE_OPEN') {
                    $this->advance(); // Skip TAG_CLOSE_OPEN
                    $closeNameToken = $this->current();
                    
                    if ($closeNameToken['type'] === 'TAG_NAME' && $closeNameToken['value'] === $tagName) {
                        $this->advance(); // Skip closing TAG_NAME
                        if ($this->current()['type'] === 'TAG_CLOSE') {
                            $this->advance(); // Skip closing TAG_CLOSE
                        }
                        break; // Found matching closing tag
                    }
                }

                $child = $this->parseNode();
                if ($child !== null) {
                    $element['children'][] = $child;
                } elseif ($this->isEOF()) {
                    break;
                } else {
                    $this->advance(); // Skip unknown token
                }
            }
        }

        return $element;
    }

    protected function parseAttribute(): ?array
    {
        $nameToken = $this->current();
        $name = $nameToken['value'];
        $this->advance(); // Skip ATTR_NAME

        $value = null;
        if ($this->current()['type'] === 'ATTR_VALUE') {
            $valueToken = $this->current();
            $value = $valueToken['value'];
            $this->advance(); // Skip ATTR_VALUE
        }

        /* Parse attribute value for expressions */
        /* Check for {expression} syntax */
        if ($value !== null && preg_match('/^{(.+)}$/', $value, $matches)) {
            /* If name is empty, this is an expression-only attribute */
            /* The expression should evaluate to the attribute name (or empty string) */
            if ($name === '') {
                return [
                    'name' => '',
                    'value' => [
                        'type' => 'Expression',
                        'code' => trim($matches[1]),
                    ],
                ];
            }
            return [
                'name' => $name,
                'value' => [
                    'type' => 'Expression',
                    'code' => trim($matches[1]),
                ],
            ];
        }
        
        /* Check for PHP echo tags inside attribute value (e.g., class="btn <?= $active ? 'active' : '' ?>" */
        if ($value !== null && preg_match('/<\?=?\s*.+?\s*\?>/', $value)) {
            /* Extract PHP code parts and create expression that concatenates static parts with PHP results */
            /* Use preg_match_all to find all PHP tags and their positions */
            $exprParts = [];
            $matches = [];
            preg_match_all('/<\?=?\s*(.+?)\s*\?>/s', $value, $matches, PREG_OFFSET_CAPTURE);
            
            if (!empty($matches[0])) {
                $lastPos = 0;
                $valueLen = strlen($value);
                
                foreach ($matches[0] as $index => $match) {
                    $matchPos = $match[1];
                    $matchLen = strlen($match[0]);
                    $phpCode = $matches[1][$index][0];
                    
                    /* Static part before PHP tag */
                    if ($matchPos > $lastPos) {
                        $staticPart = substr($value, $lastPos, $matchPos - $lastPos);
                        if ($staticPart !== '') {
                            $exprParts[] = var_export($staticPart, true);
                        }
                    }
                    
                    /* PHP code part - wrap in parentheses and cast to string */
                    if ($phpCode !== '') {
                        $exprParts[] = '(string)(' . trim($phpCode) . ')';
                    }
                    
                    $lastPos = $matchPos + $matchLen;
                }
                
                /* Add remaining static part after last PHP tag */
                if ($lastPos < $valueLen) {
                    $staticPart = substr($value, $lastPos);
                    if ($staticPart !== '') {
                        $exprParts[] = var_export($staticPart, true);
                    }
                }
                
                if (count($exprParts) > 0) {
                    return [
                        'name' => $name,
                        'value' => [
                            'type' => 'Expression',
                            'code' => implode(' . ', $exprParts),
                        ],
                    ];
                }
            }
        }

        return [
            'name' => $name,
            'value' => $value ?? true,
        ];
    }

    protected function parseExpression(): array
    {
        $lbraceToken = $this->current();
        $this->advance(); // Skip LBRACE

        $code = '';
        $depth = 1;

        while (!$this->isEOF() && $depth > 0) {
            $token = $this->current();
            
            if ($token['type'] === 'LBRACE') {
                $depth++;
            } elseif ($token['type'] === 'RBRACE') {
                $depth--;
                if ($depth === 0) {
                    $this->advance(); // Skip closing RBRACE
                    break;
                }
            } else {
                $code .= $token['value'];
            }
            
            $this->advance();
        }

        return [
            'type' => 'Expression',
            'code' => trim($code),
            'line' => $lbraceToken['line'],
            'column' => $lbraceToken['column'],
        ];
    }

    protected function current(): array
    {
        return $this->tokens[$this->position] ?? ['type' => 'EOF', 'value' => ''];
    }

    protected function advance(): void
    {
        $this->position++;
    }

    protected function isEOF(): bool
    {
        return $this->current()['type'] === 'EOF';
    }
}

